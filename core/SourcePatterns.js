import AuxinSource from './AuxinSource';
import Vec2 from 'vec2';
import { random } from './Utilities';
import Path from './Path';

export default class SourcePatterns {
  constructor() {}

  static getRandomSources(numSources, ctx, bounds = undefined, obstacles = undefined) {
    let sources = [];
    let x, y;
    let isInsideAnyBounds, isInsideAnyObstacle;

    for(let i=0; i<numSources; i++) {
      x = random(window.innerWidth);
      y = random(window.innerHeight);
      isInsideAnyBounds = false;
      isInsideAnyObstacle = false;

      // Only allow root veins inside of defined bounds
      if(bounds != undefined && bounds.length > 0) {
        for(let bound of bounds) {
          if(bound.contains(x, y)) {
            isInsideAnyBounds = true;
          }
        }
      }

      // Don't allow any root veins that are inside of an obstacle
      if(obstacles != undefined && obstacles.length > 0) {
        for(let obstacle of obstacles) {
          if(obstacle.contains(x, y)) {
            isInsideAnyObstacle = true;
          }
        }
      }

      if(
        (isInsideAnyBounds || bounds === undefined) &&
        (!isInsideAnyObstacle || obstacles === undefined)
      ) {
        sources.push(
          new AuxinSource(
            new Vec2(x,y),
            ctx
          )
        );
      }
    }

    return sources;
  }

  // TODO: add "jitter" parameter for randomness
  static getGridOfSources(numRows, numColumns, ctx, bounds = undefined, obstacles = undefined) {
    let sources = [];
    let x, y;
    let isInsideAnyBounds, isInsideAnyObstacle;

    for(let i=0; i<=numRows; i++) {
      for(let j=0; j<=numColumns; j++) {
        x = (window.innerWidth / numColumns) * j + random(-10,10);
        y = (window.innerHeight / numRows) * i + random(-10,10);
        isInsideAnyBounds = false;
        isInsideAnyObstacle = false;

        // Only allow root veins inside of defined bounds
        if(bounds != undefined && bounds.length > 0) {
          for(let bound of bounds) {
            if(bound.contains(x, y)) {
              isInsideAnyBounds = true;
            }
          }
        }

        // Don't allow any root veins that are inside of an obstacle
        if(obstacles != undefined && obstacles.length > 0) {
          for(let obstacle of obstacles) {
            if(obstacle.contains(x, y)) {
              isInsideAnyObstacle = true;
            }
          }
        }

        if(
          (isInsideAnyBounds || bounds === undefined) &&
          (!isInsideAnyObstacle || obstacles === undefined)
        ) {
          sources.push(
            new AuxinSource(
              new Vec2(x,y),
              ctx
            )
          );
        }
      }
    }

    return sources;
  }
}